;========== C declarations ========================================================================

;; alloc
(decl @malloc (types u64) i8*)
(decl @free (types i8*) void)

;                     ptr newsize -> newptr
(decl @realloc (types i8* u64) i8*)
; remember to store newptr or keep it as a value as it might change from ptr

;                    len size
(decl @calloc (types u64 u64) i8*)

;; io
(decl @printf (types i8* ...)     i32)
(decl @puts   (types i8*)         i32)

;                    fd  src len -> len
(decl @write  (types i32 i8* u64) i64)

;                    fd  buf len -> i64
(decl @read   (types i32 i8* u64) i64)

;                    fd -> unisuccess
(decl @fflush (types i32) i32)

; STDIN = 0, STDOUT = 1, STDERR = 2

;                    dest src len
(decl @memcpy (types i8* i8* u64) i8*)

;; file

;            filename, O_flags, S_mode -> fd:i32
(decl @open (types i8* i32 ...) i32)
; #define O_RDONLY	     00

;             file_descriptor, offset, SEEK_whence
(decl @lseek (types i32 i64 i32) i64)
; # define SEEK_END	2	/* Seek from end of file.  */

;            result:out i8*, length, prot, flags, fd, offset
(decl @mmap (types i8* u64 i32 i32 i32 i64) i8*)
; #define PROT_READ	0x1		/* Page can be read.  */
; #define PROT_WRITE	0x2		/* Page can be written.  */
; #define MAP_PRIVATE	0x02		/* Changes are private.  */

;                    src len -> unisuccess
(decl @munmap (types i8* u64) i32)

;                   fd -> unisuccess
(decl @close (types i32) i32)

;; misc
(decl @exit (types i32) void)

; GLOSSARY
; fd -> file descripter
; len -> length
; dst -> destination
; src -> source
; prot -> protocol
; unisuccess -> unix success: 0 success, -1 on failure and set ERRNO

;========== i8* methods ===========================================================================

; NOTE: does not include trailing zero
(def @i8$ptr.length_ (params (%this i8*) (%acc u64)) u64 (do
  (if (== (load %this) 0) (do
    (return %acc)
  ))

  (return (call-tail @i8$ptr.length_ (args (cast i8* (+ 1 (cast u64 %this))) (+ %acc 1))))
))

(def @i8$ptr.length (params (%this i8*)) u64 (do
  (return (call-tail @i8$ptr.length_ (args %this 0)))
))

(def @i8$ptr.printn (params (%this i8*) (%n u64)) void (do
  (let %FD_STDOUT (+ 1 (0 i32)))
  (call @write (args %FD_STDOUT %this %n))
  (return-void)
))

(def @i8$ptr.copyalloc (params (%this i8*)) i8* (do
  (let %length (call @i8$ptr.length (args %this)))
  (let %allocated (call @malloc (args (+ %length 1))))
  (store 0 (cast i8* (+ %length (cast u64 %allocated))))
  (call @memcpy (args %allocated %this %length))
  (return %allocated)
))

(def @i8.print (params (%this i8)) void (do
  (auto %c i8)
  (store %this %c)  
  (let %FD_STDOUT (+ 1 (0 i32)))
  (call @write (args %FD_STDOUT %c 1))
  (return-void)
))

(def @i8$ptr.swap (params (%this i8*) (%other i8*)) void (do
  (let %this_value (load %this))
  (let %other_value (load %other))
  (store %this_value %other)
  (store %other_value %this)
  (return-void)
))

(def @i8$ptr.eqn (params (%this i8*) (%other i8*) (%len u64)) i1 (do
  (if (== 0 %len) (do
    (return true)
  ))

  (if (!= (load %this) (load %other)) (do
    (return false)
  ))

  (let %next-this  (cast i8* (+ 1 (cast u64 %this))))
  (let %next-other (cast i8* (+ 1 (cast u64 %other))))
  (return (call @i8$ptr.eqn (args %next-this %next-other (- %len 1))))
))

(def @println params void (do
  (let %NEWLINE (+ 10 (0 i8)))
  (call @i8.print (args %NEWLINE))
  (return-void)
))

;========== i8* tests =============================================================================

(def @test.i8$ptr-eqn params void (do
  (auto %a %struct.String)
  (store (call @String.makeEmpty args) %a)
  (auto %b %struct.String)
  (store (call @String.makeEmpty args) %b)

  (call @String$ptr.pushChar (args %a 65))
  (call @String$ptr.pushChar (args %a 66))
  (call @String$ptr.pushChar (args %a 67))
  (call @String$ptr.pushChar (args %a 68))

  (call @String$ptr.pushChar (args %b 65))
  (call @String$ptr.pushChar (args %b 66))
  (call @String$ptr.pushChar (args %b 67))
  (call @String$ptr.pushChar (args %b 68))

; FIXME suspicious
  (let %a-cstr (cast i8* %a))
  (let %b-cstr (cast i8* %b))

  (call @i8.print (args (+ 48 (cast i8 (call @i8$ptr.eqn (args %a-cstr %b-cstr 5))))))
  (return-void)
))

;========== StringView ============================================================================

; NOTE: does not include trailing zero
(struct %struct.StringView
  (%ptr i8*)
  (%size u64))

(def @StringView.makeEmpty params %struct.StringView (do
  (auto %result %struct.StringView)
  (store (cast i8* (0 i64)) (index %result 0))
  (store 0 (index %result 1))
  (return (load %result))
))

(def @StringView$ptr.set (params (%this %struct.StringView*) (%charptr i8*)) void (do
  (store %charptr (index %this 0))
  (store (call @i8$ptr.length (args %charptr)) (index %this 1))
  (return-void)
))

(def @StringView.make (params (%charptr i8*) (%size u64)) %struct.StringView (do
  (auto %result %struct.StringView)
  (store %charptr (index %result 0))
  (store %size (index %result 1))
  (return (load %result))
))

(def @StringView.makeFromi8$ptr (params (%charptr i8*)) %struct.StringView (do
  (auto %result %struct.StringView)
  (store %charptr (index %result 0))
  (store (call @i8$ptr.length (args %charptr)) (index %result 1))
  (return (load %result))
))

(def @StringView$ptr.print (params (%this %struct.StringView*)) void (do
  (call @i8$ptr.printn (args (load (index %this 0)) (load (index %this 1))))
  (return-void)
))

(def @StringView$ptr.eq (params (%this %struct.StringView*) (%other %struct.StringView*)) i1 (do
  (let %len (load (index %this 1)))
  (let %olen (load (index %other 1)))
  (if (!= %len %olen) (do
    (return false)
  ))
  (return (call @i8$ptr.eqn (args (load (index %this 0)) (load (index %other 0)) (+ 1 %len))))
))

(def @StringView.eq (params (%this-value %struct.StringView) (%other-value %struct.StringView)) i1 (do
  (auto %this %struct.StringView)
  (store %this-value %this)
  (auto %other %struct.StringView)
  (store %other-value %this)
  (return (call @StringView$ptr.eq (args %this %other)))
))

;========== String ================================================================================

; sizeof(String) == 8 + 8 == 16
; NOTE: does not include trailing zero in size, but %ptr owns trailing zero in memory allocation
(struct %struct.String
  (%ptr i8*)
  (%size u64)
)

(def @String.makeEmpty params %struct.String (do
  (auto %result %struct.String)
  (store (cast i8* (0 i64)) (index %result 0))
  (store 0 (index %result 1))
  (return (load %result))
))

; allocates memory using @i8$ptr.copyalloc
; FIXME call setalloc or have some kind of notation for ownership of result
(def @String$ptr.set (params (%this %struct.String*) (%charptr i8*)) void (do
  (store (call @i8$ptr.copyalloc (args %charptr)) (index %this 0))
  (store (call @i8$ptr.length (args %charptr)) (index %this 1))
  (return-void)
))

(def @String.makeFromi8$ptr (params (%charptr i8*)) %struct.String (do
  (auto %this %struct.String)
  (store (call @i8$ptr.copyalloc (args %charptr)) (index %this 0))
  (store (call @i8$ptr.length (args %charptr)) (index %this 1))
  (return (load %this))
))

(def @String$ptr.copyalloc (params (%this %struct.String*)) %struct.String (do
  (auto %result %struct.String)
  (store (call @i8$ptr.copyalloc (args (load (index %this 0)))) (index %result 0))
  (store (load (index %this 1)) (index %result 1))
  (return (load %result))
))

(def @String.makeFromStringView (params (%other %struct.StringView*)) %struct.String (do
  (auto %result %struct.String)
  (store (call @i8$ptr.copyalloc (args (load (index %other 0)))) (index %result 0))
  (store (load (index %other 1)) (index %result 1))
  (return (load %result))
))

(def @String$ptr.view (params (%this %struct.String*)) %struct.StringView (do
  (return (load (cast %struct.StringView* %this)))
))

(def @String$ptr.free (params (%this %struct.String*)) void (do
  (call @free (args (load (index %this 0))))
  (return-void)
))

(def @String$ptr.setFromChar (params (%this %struct.String*) (%c i8)) void (do
  (let %ptr-ref (index %this 0))
  (let %size-ref (index %this 1))

  (let %ptr (call @malloc (args 2)))
  (store %c %ptr)
  (store 0 (cast i8* (+ 1 (cast u64 %ptr))))
  (store %ptr %ptr-ref)
  (store 1 %size-ref)
  (return-void)
))

; maintains ownership of %this but does not consume ownership of %other
(def @String$ptr.append (params 
    (%this %struct.String*) 
    (%other %struct.String*)) void (do

  (let %same-string (== %this %other))
  (if %same-string (do
    (auto %temp-copy %struct.String)
    (store (call @String$ptr.copyalloc (args %other)) %temp-copy)

    (call @String$ptr.append (args %this %temp-copy))
    (call @free (args (load (index %temp-copy 0))))
    (return-void)
  ))

  (let %old-length (load (index %this 1)))
  (let %new-length (+ %old-length (load (index %other 1))))
  (store %new-length (index %this 1))
  (store 
    (call @realloc (args (load (index %this 0)) (+ 1 %new-length)))
    (index %this 0))
  (let %end-of-this-string (cast i8* (+ (cast u64 (load (index %this 0))) %old-length)))
  (call @memcpy (args
    %end-of-this-string 
    (load (index %other 0)) 
    (load (index %other 1))))
  
  (return-void)
))

(def @String$ptr.pushChar (params (%this %struct.String*) (%c i8)) void (do
  (let %ptr-ref (index %this 0))
  (let %size-ref (index %this 1))

  (if (== 0 (cast u64 (load %ptr-ref))) (do
;   TODO assert size is also zero
    (call-tail @String$ptr.setFromChar (args %this %c))
    (return-void)
  ))

  (let %old-size (load %size-ref))
; the size does not include the terminating byte, but it is guaranteed to be there
; add 1 for the null character and 1 for the pushed character, 2 total
  (store (call @realloc (args (load %ptr-ref) (+ 2 %old-size))) %ptr-ref)
  (store (+ 1 %old-size) %size-ref)

  (let %new-char-loc (cast i8* (+ %old-size (cast u64 (load (%ptr-ref))))))
  (store %c %new-char-loc)
  (return-void)
))

(def @reverse-pair (params (%begin i8*) (%end i8*)) void (do
  (if (>= (cast u64 %begin) (cast u64 %end)) (do
    (return-void)
  ))
  (call @i8$ptr.swap (args %begin %end))
  (let %next-begin (cast i8* (+ (cast u64 %begin) 1)))
  (let %next-end   (cast i8* (- (cast u64 %end) 1)))
  (call-tail @reverse-pair (args %next-begin %next-end))
  (return-void)
))

(def @String$ptr.reverse-in-place (params (%this %struct.String*)) void (do
  (let %begin (load (index %this 0)))
  (let %size (load (index %this 1)))
  (if (== 0 %size) (do (return-void)))
; begin + size -> null char, so begin + size - 1 -> last char
  (let %end (cast i8* (+ (- %size 1) (cast u64 %begin))))
  (call-tail @reverse-pair (args %begin %end))
  (return-void)
))

; even though Strings own an extra byte at the end, we don't have to print it because it's definitionally null char
(def @String$ptr.print (params (%this %struct.String*)) void (do
  (call @i8$ptr.printn (args (load (index %this 0)) (load (index %this 1))))
  (return-void)
))

(def @String$ptr.println (params (%this %struct.String*)) void (do
  (call @i8$ptr.printn (args (load (index %this 0)) (load (index %this 1))))
  (call @println args)
  (return-void)
))

;========== string tests ==========================================================================

(def @test.strlen params void (do
  (let %str-example "global string example\00")
  (call-vargs @printf (args 
    "'%s' has length %lu.\0A\00" "global string example\00" (call @i8$ptr.length (args "global string example\00"))))  
  (return-void)
))

(def @test.strview params void (do
  (auto %string-view %struct.StringView)
  (store (call @StringView.makeEmpty args) %string-view)
  (call @StringView$ptr.set (args %string-view "global string example\00"))
  (call-vargs @printf (args 
    "'%s' has length %lu.\0A\00" (load (index %string-view 0)) (load (index %string-view 1))))
  (return-void)
))

(def @test.basic-string params void (do
  (auto %string %struct.String)
  (call @String$ptr.set (args %string "basic-string test\00"))
  (call-vargs @printf (args
    "'%s' has length %lu.\0A\00" (load (index %string 0)) (load (index %string 1))))
  (return-void)
))

(def @test.string-self-append params void (do
  (auto %string %struct.String)
  (call @String$ptr.set (args %string "string-self-append test\00"))
  (call @String$ptr.append (args %string %string))
  (call @puts (args (load (index %string 0))))
  (return-void)
))

(def @test.string-append-helloworld params void (do
  (auto %hello %struct.String)
  (call @String$ptr.set (args %hello "hello, \00"))

  (auto %world %struct.String)
  (call @String$ptr.set (args %world "world\00"))

  (call @String$ptr.append (args %hello %world))
  (call @puts (args (load (index %hello 0))))

  (return-void)
))

(def @test.string-pushchar params void (do
  (auto %acc %struct.String)
  (store (call @String.makeEmpty args) %acc)

  (let %A (+ 65 (0 i8)))

  (call @String$ptr.pushChar (args %acc %A))
  (call @puts (args (load (index %acc 0))))

  (call @String$ptr.pushChar (args %acc %A))
  (call @puts (args (load (index %acc 0))))
  
  (call @String$ptr.pushChar (args %acc %A))
  (call @puts (args (load (index %acc 0))))

  (return-void)
))

(def @test.string-reverse-in-place params void (do
  (auto %acc %struct.String)
  (store (call @String.makeEmpty args) %acc)

  (let %A (+ 65 (0 i8)))

  (call @String$ptr.pushChar (args %acc %A))
  (call @puts (args (load (index %acc 0))))

  (call @String$ptr.pushChar (args %acc (+ 1 %A)))
  (call @puts (args (load (index %acc 0))))
  
  (call @String$ptr.pushChar (args %acc (+ 2 %A)))
  (call @puts (args (load (index %acc 0))))

  (let %begin (load (index %acc 0)))
  (let %size (load (index %acc 1)))
  (let %end (cast i8* (+ (- %size 1) (cast u64 %begin))))

  (call @u64.print (args %size))
  (call @i8.print (args (load %begin)))
  (call @i8.print (args (load %end)))
  (call @println args)

  (call @i8$ptr.swap (args %begin %end))
  (call @puts (args (load (index %acc 0))))

  (call @String$ptr.reverse-in-place (args %acc))
  (call @puts (args (load (index %acc 0))))

  (return-void)
))

;========== File ==================================================================================

(struct %struct.File
  (%name %struct.String)
  (%file_descriptor i32))

(def @File.open (params (%filename-view %struct.StringView*)) %struct.File (do
  (let %O_RDONLY (+ 1 (0 i32)))

  (auto %result %struct.File)
  
  (let %filename (load (index %filename-view 0)))
  (store (call @String.makeFromStringView (args %filename-view)) (index %result 0))

  (let %fd (call-vargs @open (args %filename %O_RDONLY)))
  (store %fd (index %result 1))
  (return (load %result))
))

(def @File.openrw (params (%filename-view %struct.StringView*)) %struct.File (do
  (let %O_RDWR (+ 2 (0 i32)))

  (auto %result %struct.File)
  
  (let %filename (load (index %filename-view 0)))
  (store (call @String.makeFromStringView (args %filename-view)) (index %result 0))

  (let %fd (call-vargs @open (args %filename %O_RDWR)))
  (store %fd (index %result 1))
  (return (load %result))
))

(def @File$ptr.getSize (params (%this %struct.File*)) i64 (do
  (let %SEEK_END (+ 2 (0 i32)))
  (return (call @lseek (args (load (index %this 1)) 0 %SEEK_END)))
))

(def @File$ptr.read (params (%this %struct.File*)) %struct.StringView (do
  (let %PROT_READ (+ 3 (0 i32)))
  (let %MAP_PRIVATE (+ 2 (0 i32)))

  (let %file-length (call @File$ptr.getSize (args %this)))
  (let %char-ptr (call @mmap (args (cast i8* (0 u64)) %file-length %PROT_READ %MAP_PRIVATE (load (index %this 1)) 0)))
  (return (call @StringView.make (args %char-ptr %file-length)))
))

(def @File$ptr.readwrite (params (%this %struct.File*)) %struct.StringView (do
  (let %PROT_RDWR (+ 3 (0 i32)))
  (let %MAP_PRIVATE (+ 2 (0 i32)))

  (let %file-length (call @File$ptr.getSize (args %this)))
  (let %char-ptr (call @mmap (args (cast i8* (0 u64)) %file-length %PROT_RDWR %MAP_PRIVATE (load (index %this 1)) 0)))
  (return (call @StringView.make (args %char-ptr %file-length)))
))

(def @File.unread (params (%view %struct.StringView*)) void (do
  (call @munmap (args (load (index %view 0)) (load (index %view 1))))
  (return-void)
))

(def @File$ptr.close (params (%this %struct.File*)) void (do
; TODO
  (call @close (args (load (index %this 1))))
  (return-void)
))

;========== File tests ============================================================================

(def @test.file-cat params void (do
  (auto %filename %struct.StringView)
  (call @StringView$ptr.set (args %filename "todo.json\00"))
  
  (auto %file %struct.File)
  (store (call @File.open (args %filename)) %file)
  
; print file name
  (call @String$ptr.println (args (index %file 0)))

  (auto %content %struct.StringView)
  (store (call @File$ptr.read (args %file)) %content)

  (call @StringView$ptr.print (args %content))

  (call @File.unread (args %content))
  (call @File$ptr.close (args %file))

  (return-void)
))

(def @test.file-size params void (do
  (auto %filename %struct.StringView)
	(call @StringView$ptr.set (args %filename "lib2/core.bb.type.tall\00"))
  
  (auto %file %struct.File)
  (store (call @File.open (args %filename)) %file)

  (let %size (call @File$ptr.getSize (args %file)))

  (call-vargs @printf (args "%ul\0A\00" %size))

  (call @File$ptr.close (args %file))

  (return-void)
))

;========== Reader ================================================================================

(struct %struct.Reader
  (%content %struct.StringView)
  (%iter i8*)
  (%prev i8)
)

(def @Reader$ptr.set (params (%this %struct.Reader*) (%string-view %struct.StringView*)) void (do
  (store (load %string-view) (index %this 0))
  (store (load (index %string-view 0)) (index %this 1))
  (store 0 (index %this 2))
  (return-void)
))

(def @Reader$ptr.peek (params (%this %struct.Reader*)) i8 (do
  (return (load (load (index %this 1))))
))

(def @Reader$ptr.get (params (%this %struct.Reader*)) i8 (do
  (let %iter-ref (index %this 1))
  (let %char (load (load %iter-ref)))
  (store %char (index %this 2))
  (store (cast i8* (+ 1 (cast u64 (load %iter-ref)))) %iter-ref)
  (return %char)
))

(def @Reader$ptr.pos (params (%this %struct.Reader*)) u64 (do
  (let %iter (load (index %this 1)))
  (let %start (load (index (index %this 0) 0)))
  (let %result (- (cast u64 %iter) (cast u64 %start)))
  (return %result)
))

; a Reader is done when %iter points to the end of %content
(def @Reader$ptr.done (params (%this %struct.Reader*)) i1 (do
  (let %content (index %this 0))
  (let %content-end (cast i8* (+ 
    (cast u64 (load (index %content 0)))
    (load (index %content 1))
  )))
  (let %iter (load (index %this 1)))
  (return (== %iter %content-end))
))

(def @Reader$ptr.reset (params (%this %struct.Reader*)) void (do
  (let %string-view (index %this 0))
  (store (load (index %string-view 0)) (index %this 1))
  (store 0 (index %this 2))
  (return-void)
))

;========== Reader tests ==========================================================================

(def @test.Reader-get$lambda0 (params (%reader %struct.Reader*) (%i i32)) void (do
  (if (== %i 0) (do
    (return-void)
  ))
  (call @i8.print (args (call @Reader$ptr.get (args %reader))))
  (call-tail @test.Reader-get$lambda0 (args %reader (- %i 1)))
  (return-void)
))

(def @test.Reader-get params void (do
  (auto %filename %struct.StringView)
  (call @StringView$ptr.set (args %filename "lib2/core.bb.type.tall\00"))
  
  (auto %file %struct.File)
  (store (call @File.open (args %filename)) %file)
  
; print file name
  (call @String$ptr.println (args (index %file 0)))

  (auto %content %struct.StringView)
  (store (call @File$ptr.read (args %file)) %content)

; print content
; (call @StringView$ptr.print (args %content))

  (auto %reader %struct.Reader)
  (call @Reader$ptr.set (args %reader %content))

  (call @test.Reader-get$lambda0 (args %reader 50))

  (call @println args)

  (call @File.unread (args %content))
  (call @File$ptr.close (args %file))
  (return-void)
))

(def @test.Reader-done$lambda0 (params (%reader %struct.Reader*)) void (do
  (call @i8.print (args (call @Reader$ptr.get (args %reader))))
  (if (- 1 (call @Reader$ptr.done (args %reader))) (do
    (call-tail @test.Reader-done$lambda0 (args %reader))
  ))
  (return-void)
))

(def @test.Reader-done params void (do
  (auto %filename %struct.StringView)
  (call @StringView$ptr.set (args %filename "todo.json\00"))
  
  (auto %file %struct.File)
  (store (call @File.open (args %filename)) %file)
  
; print file name
  (call @String$ptr.println (args (index %file 0)))

  (auto %content %struct.StringView)
  (store (call @File$ptr.read (args %file)) %content)

; print content
; (call @StringView$ptr.print (args %content))

  (auto %reader %struct.Reader)
  (call @Reader$ptr.set (args %reader %content))

  (call @test.Reader-done$lambda0 (args %reader))

  (call @println args)

  (call @File.unread (args %content))
  (call @File$ptr.close (args %file))
  (return-void)
))

;========== Texp ==================================================================================

; sizeof(Texp) = 16 + 8 + 8 + 8
;              = 40
(struct %struct.Texp
  (%value %struct.String)
  (%children %struct.Texp*)
  (%length u64)
  (%capacity u64)
)

; consumes ownership of %value's memory allocation
; FIXME or does it?
; TODO rename to setFromString$ptr
(def @Texp$ptr.setFromString (params (%this %struct.Texp*) (%value %struct.String*)) void (do
  (store (load %value) (index %this 0))
  (store (cast %struct.Texp* (0 u64)) (index %this 1))
  (store 0 (index %this 2))
  (store 0 (index %this 3))
  (return-void)
))

(def @Texp.makeFromi8$ptr (params (%value-cstr i8*)) %struct.Texp (do
  (auto %result %struct.Texp)
  (store (call @String.makeFromi8$ptr (args %value-cstr)) (index %result 0))
  (store (cast %struct.Texp* (0 u64)) (index %result 1))
  (store 0 (index %result 2))
  (store 0 (index %result 3))
  (return (load %result))
))

; copies %item into a conditionally resized child array in %this
; takes ownership of %item and %item's string
(def @Texp$ptr.push$ptr (params (%this %struct.Texp*) (%item %struct.Texp*)) void (do
  (let %children-ref (index %this 1))
  (let %length-ref (index %this 2))
  (let %cap-ref (index %this 3))

  (if (== (load %length-ref) (load %cap-ref)) (do

    (let %old-capacity (load %cap-ref))
    (if (== 0 %old-capacity) (do
      (store 1 %cap-ref)
    ))
    (if (!= 0 %old-capacity) (do
      (store (* 2 %old-capacity) %cap-ref)
    ))
    (let %new-capacity (load %cap-ref))
    
    (let %old-children (load %children-ref))
    (let %new-children (cast %struct.Texp* (call @realloc (args 
      (cast i8* %old-children) 
      (* 40 %new-capacity)))))
    (store %new-children (index %this 1))
  ))

  (let %children-base (cast u64 (load %children-ref)))
  (let %new-child-loc (cast %struct.Texp* 
    (+ (* 40 (cast u64 (load %length-ref))) %children-base)
  ))
  (store (load %item) %new-child-loc)

  (store (+ 1 (load %length-ref)) %length-ref)

  (return-void)
))

(def @Texp$ptr.push (params (%this %struct.Texp*) (%item %struct.Texp)) void (do
  (auto %local-item %struct.Texp)
  (store %item %local-item)
  (call @Texp$ptr.push$ptr (args %this %local-item))
  (return-void)
))

(def @Texp$ptr.parenPrint$lambda.child-iter (params (%this %struct.Texp*) (%child-index u64)) void (do
  (let %children (load (index %this 1)))
  (let %length (load (index %this 2)))

  (if (== %child-index %length) (do
    (return-void)
  ))

  (let %curr (cast %struct.Texp*  
    (+ (* 40 %child-index) (cast u64 %children))
  ))

  (if (!= 0 %child-index) (do
    (let %SPACE  (+ 32 (0 i8)))
    (call @i8.print (args %SPACE))
  ))

  (call @Texp$ptr.parenPrint (args %curr))
  (call-tail @Texp$ptr.parenPrint$lambda.child-iter (args %this (+ 1 %child-index)))
  (return-void)
))

(def @Texp$ptr.parenPrint (params (%this %struct.Texp*)) void (do
  (let %value-ref (index %this 0))
  (let %length (load (index %this 2)))

  (if (== 0 %length) (do
    (call @String$ptr.print (args %value-ref))
    (return-void)
  ))
  
  (let %LPAREN (+ 40 (0 i8)))
  (let %RPAREN (+ 41 (0 i8)))
  (let %SPACE  (+ 32 (0 i8)))

  (call @i8.print (args %LPAREN))
  (call @String$ptr.print (args %value-ref))
  (call @i8.print (args %SPACE))
  (call @Texp$ptr.parenPrint$lambda.child-iter (args %this 0))
  (call @i8.print (args %RPAREN))

  (return-void)
))

(def @Texp$ptr.free$lambda.child-iter (params (%this %struct.Texp*) (%child-index u64)) void (do
  (let %children (load (index %this 1)))
  (let %length (load (index %this 2)))

  (if (== %child-index %length) (do
    (return-void)
  ))

  (let %curr (cast %struct.Texp*  
    (+ (* 40 %child-index) (cast u64 %children))
  ))

  (call-tail @Texp$ptr.free$lambda.child-iter (args %this (+ 1 %child-index)))
  (return-void)
))

(def @Texp$ptr.last (params (%this %struct.Texp*)) %struct.Texp* (do
  (let %len (load (index %this 2)))
  (let %first-child (load (index %this 1)))
  (let %last (cast %struct.Texp*
    (+ (cast u64 %first-child)
       (* 40 (- %len 1)))
  ))
  (return %last)
))

(def @Texp$ptr.child (params (%this %struct.Texp*) (%i u64)) %struct.Texp* (do
; TODO consider bounds checking 
  (let %first-child (load (index %this 1)))
  (let %child (cast %struct.Texp*
    (+ (cast u64 %first-child)
       (* 40 %i))
  ))
  (return %child)
))

(def @Texp$ptr.free (params (%this %struct.Texp*)) void (do
  (call @String$ptr.free (args (index %this 0)))
  (call @free (args (cast i8* (load (index %this 1)))))
  (call @Texp$ptr.free$lambda.child-iter (args %this 0))
  (return-void)
))

(def @Texp$ptr.find_ (params (%this %struct.Texp*) (%last %struct.Texp*) (%key %struct.StringView*)) %struct.Texp* (do
  (let %view (call @String$ptr.view (args (index %this 0))))
  (if (call @StringView.eq (args %view (load %key))) (do
    (return %this)
  ))
  (if (== %this %last) (do
    (return (cast %struct.Texp* (0 u64)))
  ))
  (let %next (cast %struct.Texp* (+ 40 (cast u64 %this))))
  (return (call @Texp$ptr.find_ (args %next %last %key)))
))

(def @Texp$ptr.find (params (%this %struct.Texp*) (%key %struct.StringView*)) %struct.Texp* (do
  (let %first (load (index %this 1)))
  (let %last (call @Texp$ptr.last (args %this)))
  (return (call @Texp$ptr.find_ (args %first %last %key)))
))

; pushes curr onto result until curr == last
(def @Texp$ptr.clone_ (params (%acc %struct.Texp*) (%curr %struct.Texp*) (%last %struct.Texp*)) void (do
  (auto %curr-clone %struct.Texp)
  (store (call @Texp$ptr.clone (args %curr)) %curr-clone)
  (call @Texp$ptr.push$ptr (args %acc %curr-clone))

  (if (== %last %curr) (return-void))

  (let %next (cast %struct.Texp* (+ 40 (cast u64 %curr))))
  (call @Texp$ptr.clone_ (args %acc %next %last))
  (return-void)
))

(def @Texp$ptr.clone (params (%this %struct.Texp*)) %struct.Texp (do
  (auto %texp %struct.Texp)
  (store (call @String$ptr.copyalloc (args (index %this 0))) (index %texp 0))

  (call @Texp$ptr.clone_ (args %texp (load (index %texp 1)) (call @Texp$ptr.last (args %texp))))

  (return (load %texp))
))

(def @Texp$ptr.value-view (params (%this %struct.Texp*)) %struct.StringView (do
  (return (call @String$ptr.view (args (index %this 0))))
))

(def @Texp$ptr.value-check (params (%this %struct.Texp*) (%check i8*)) i1 (do
  (let %check-view (call @StringView.makeFromi8$ptr (args %check)))
  (let %value-view (call @String$ptr.view (args (index %this 0))))
  (return (call @StringView.eq (args %check-view %value-view)))
))

;========== Texp tests ============================================================================

(def @test.Texp-basic$lamdba.dump (params (%texp %struct.Texp*)) void (do
  (call @println args)
  (call @u64.print (args (load (index %texp 2))))

  (call @Texp$ptr.parenPrint (args %texp))
  (call @println args)
  (return-void)
))

(def @test.Texp-basic params void (do
  (auto %hello-string %struct.String)
  (call @String$ptr.set (args %hello-string "hello\00"))

  (auto %child0-string %struct.String)
  (call @String$ptr.set (args %child0-string "child-0\00"))

  (auto %child1-string %struct.String)
  (call @String$ptr.set (args %child1-string "child-1\00"))

  (auto %child2-string %struct.String)
  (call @String$ptr.set (args %child2-string "child-2\00"))

  (auto %texp %struct.Texp)
  (call @Texp$ptr.setFromString (args %texp %hello-string))

  (call @test.Texp-basic$lamdba.dump (args %texp))

; allocate children
  (auto %texp-child %struct.Texp)

; child 1
  (call @Texp$ptr.setFromString (args %texp-child %child0-string))
  (call @Texp$ptr.push$ptr (args %texp %texp-child))

  (call @test.Texp-basic$lamdba.dump (args %texp))

; child 2
  (call @Texp$ptr.setFromString (args %texp-child %child1-string))
  (call @Texp$ptr.push$ptr (args %texp %texp-child))

  (call @test.Texp-basic$lamdba.dump (args %texp))

; child 3
  (call @Texp$ptr.setFromString (args %texp-child %child2-string))
  (call @Texp$ptr.push$ptr (args %texp %texp-child))

  (call @test.Texp-basic$lamdba.dump (args %texp))

  (call @Texp$ptr.free (args %texp))
; FIXME still leaking some strings I think, 24 bytes on valgrind

  (return-void)
))

(def @test.Texp-clone params void (do
  (auto %hello-string %struct.String)
  (call @String$ptr.set (args %hello-string "hello\00"))

  (auto %child0-string %struct.String)
  (call @String$ptr.set (args %child0-string "child-0\00"))

  (auto %child1-string %struct.String)
  (call @String$ptr.set (args %child1-string "child-1\00"))

  (auto %child2-string %struct.String)
  (call @String$ptr.set (args %child2-string "child-2\00"))

  (auto %texp %struct.Texp)
  (call @Texp$ptr.setFromString (args %texp %hello-string))

  (call @test.Texp-basic$lamdba.dump (args %texp))

; allocate children
  (auto %texp-child %struct.Texp)

; child 1
  (call @Texp$ptr.setFromString (args %texp-child %child0-string))
  (call @Texp$ptr.push$ptr (args %texp %texp-child))

  (call @test.Texp-basic$lamdba.dump (args %texp))

; child 2
  (call @Texp$ptr.setFromString (args %texp-child %child1-string))
  (call @Texp$ptr.push$ptr (args %texp %texp-child))

  (call @test.Texp-basic$lamdba.dump (args %texp))

; child 3
  (call @Texp$ptr.setFromString (args %texp-child %child2-string))
  (call @Texp$ptr.push$ptr (args %texp %texp-child))

  (call @test.Texp-basic$lamdba.dump (args %texp))

  (call @Texp$ptr.free (args %texp))
; FIXME still leaking some strings I think, 24 bytes on valgrind

  (return-void)
))

;========== int string conv =======================================================================

(def @u64.string_ (params (%this u64) (%acc %struct.String*)) void (do
  (if (== 0 %this) (do
    (return-void)
  ))

  (let %ZERO (+ 48 (0 i8)))
  (let %top  (% %this 10))
  (let %c (+ %ZERO (cast i8 %top)))
  (call @String$ptr.pushChar (args %acc %c))

  (let %rest (/ %this 10))
  (call-tail @u64.string_ (args %rest %acc))
  (return-void)
))

(def @u64.string (params (%this u64)) %struct.String (do
  (auto %acc %struct.String)
  (store (call @String.makeEmpty args) %acc)  

  (let %ZERO (+ 48 (0 i8)))

  (if (== 0 %this) (do
    (call @String$ptr.pushChar (args %acc %ZERO))
    (return (load %acc))
  ))

  (call @u64.string_ (args %this %acc))
  (call @String$ptr.reverse-in-place (args %acc))

  (return (load %acc))
))

(def @u64.print (params (%this u64)) void (do
  (auto %string %struct.String)
  (store (call @u64.string (args %this)) %string)
  (call @String$ptr.print (args %string))
  (return-void)
))

(def @u64.println (params (%this u64)) void (do
  (call @u64.print (args %this))
  (call @println args)
  (return-void)
))

;========== int string conv tests =================================================================

(def @test.u64-print params void (do
  (call @u64.print (args 12408124))
  (call @println args)
  (return-void)
))

;========== Parser ================================================================================

(def @i8.isspace (params (%this i8)) i1 (do

; ' ', space 
  (if (== %this 32) (do (return true)))

; '\f', form feed
  (if (== %this 12) (do (return true)))

; '\n', new line
  (if (== %this 10) (do (return true)))
  
; '\r', carriage return
  (if (== %this 13) (do (return true)))

; '\t', horizontal tab
  (if (== %this 9) (do (return true)))

; '\v', vertical tab
  (if (== %this 11) (do (return true)))

  (return false)
))

(struct %struct.Parser
  (%reader %struct.Reader))

(def @Parser$ptr.whitespace (params (%this %struct.Parser*)) void (do
  (if (call @i8.isspace (args (call @Reader$ptr.peek (args (index %this 0))))) (do
    (call @Reader$ptr.get (args (index %this 0)))
    (call-tail @Parser$ptr.whitespace (args %this))
    (return-void)
  ))
  (return-void)
))

(def @Parser$ptr.word_ (params (%this %struct.Parser*) (%acc %struct.String*)) void (do
  (let %reader (index %this 0))
  (if (call @Reader$ptr.done (args %reader)) (do
    (return-void)
  ))

  (let %LPAREN (+ 40 (0 i8)))
  (let %RPAREN (+ 41 (0 i8)))

  (let %c (call @Reader$ptr.peek (args %reader)))
  (if (== %LPAREN %c) (do (return-void)))
  (if (== %RPAREN %c) (do (return-void)))
  (if (call @i8.isspace (args %c)) (do (return-void)))

  (call @Reader$ptr.get (args %reader))
  (call @String$ptr.pushChar (args %acc %c))
  (call-tail @Parser$ptr.word_ (args %this %acc))
  (return-void)
))

(def @Parser$ptr.word (params (%this %struct.Parser*)) %struct.String (do
  (call @Parser$ptr.whitespace (args %this))
; TODO CHECK not r.done OTHERWISE "reached end of file while parsing word"

  (auto %acc %struct.String)
  (store (call @String.makeEmpty args) %acc)
  (call @Parser$ptr.word_ (args %this %acc))
  (return (load %acc))
))

; parses string contents until the string is closed
(def @Parser$ptr.string_ (params (%this %struct.Parser*) (%acc %struct.String*)) void (do
  (let %QUOTE (+ 34 (0 i8)))
  (let %BACKSLASH (+ 92 (0 i8)))

  (if (== %QUOTE (call @Reader$ptr.peek (args (index %this 0)))) (do
    (let %prev (load (index (index %this 0) 2)))
    (if (!= %BACKSLASH %prev) (do
      (return-void)
    ))
  ))

  (let %c (call @Reader$ptr.get (args (index %this 0))))
  (call @String$ptr.pushChar (args %acc %c))
  (call-tail @Parser$ptr.string_ (args %this %acc))
  (return-void)
))

(def @Parser$ptr.string (params (%this %struct.Parser*)) %struct.Texp (do
  (auto %acc %struct.String)
  (store (call @String.makeEmpty args) %acc)

; TODO assert r.peek == '\"'
  (call @String$ptr.pushChar (args %acc (call @Reader$ptr.get (args (index %this 0)))))
  
  (call @Parser$ptr.string_ (args %this %acc))

; TODO assert r.peek == '\"'
  (call @String$ptr.pushChar (args %acc (call @Reader$ptr.get (args (index %this 0)))))
  
  (auto %texp %struct.Texp)
  (call @Texp$ptr.setFromString (args %texp %acc))
  (return (load %texp))
))

(def @Parser$ptr.atom (params (%this %struct.Parser*)) %struct.Texp (do
; TODO assert r.peek != ')'

; string
  (let %QUOTE (+ 34 (0 i8)))
  (if (== %QUOTE (call @Reader$ptr.peek (args (index %this 0)))) (do
    (return (call @Parser$ptr.string (args %this)))
  ))

; TODO char

; atom
  (auto %texp %struct.Texp)
  (auto %word %struct.String)
  (store (call @Parser$ptr.word (args %this)) %word)
  (call @Texp$ptr.setFromString (args %texp %word))
  (return (load %texp))
))

(def @Parser$ptr.list_ (params (%this %struct.Parser*) (%acc %struct.Texp*)) void (do
  (let %RPAREN (+ 41 (0 i8)))

  (if (!= %RPAREN (call @Reader$ptr.peek (args (index %this 0)))) (do
    (auto %texp %struct.Texp)
    (store (call @Parser$ptr.texp (args %this)) %texp)
    (call @Texp$ptr.push$ptr (args %acc %texp))
    (call @Parser$ptr.whitespace (args %this))
    (call @Parser$ptr.list_ (args %this %acc))
  ))
  (return-void)
))

(def @Parser$ptr.list (params (%this %struct.Parser*)) %struct.Texp (do
; TODO assert r.get == '('
  (call @Reader$ptr.get (args (index %this 0)))

  (auto %curr %struct.Texp)
  (auto %word %struct.String)
  (store (call @Parser$ptr.word (args %this)) %word)
  (call @Texp$ptr.setFromString (args %curr %word))

  (call @Parser$ptr.whitespace (args %this))

  (call @Parser$ptr.list_ (args %this %curr))
  
; TODO assert r.get == ')'
  (call @Reader$ptr.get (args (index %this 0)))
  
  (return (load %curr))
))

(def @Parser$ptr.texp (params (%this %struct.Parser*)) %struct.Texp (do
; if r.peek = '(' list otherwise atom
  (let %LPAREN (+ 40 (0 i8)))

  (call @Parser$ptr.whitespace (args %this))
  
  (if (== %LPAREN (call @Reader$ptr.peek (args (index %this 0)))) (do
    (return (call @Parser$ptr.list (args %this)))
  ))

  (return (call @Parser$ptr.atom (args %this)))
))

(def @Parser$ptr.collect (params (%this %struct.Parser*) (%parent %struct.Texp*)) void (do
  (if (call @Reader$ptr.done (args (index %this 0))) (do (return-void)))

  (auto %child %struct.Texp)
  (store (call @Parser$ptr.texp (args %this)) %child)
  (call @Texp$ptr.push$ptr (args %parent %child))

  (call @Parser$ptr.collect (args %this %parent))

  (return-void)
))

(def @Parser$ptr.remove-comments (params (%this %struct.Parser*) (%state i8)) void (do 
  (let %NEWLINE       (+ 10 (0 i8)))
  (let %SPACE         (+ 32 (0 i8)))
  (let %QUOTE         (+ 34 (0 i8)))
  (let %SEMICOLON     (+ 59 (0 i8)))
  (let %BACKSLASH     (+ 92 (0 i8)))

  
  (let %COMMENT_STATE (- (0 i8) 1))
  (let %START_STATE   (+ 0 (0 i8)))
  (let %STRING_STATE  (+ 1 (0 i8)))
  (let %CHAR_STATE    (+ 2 (0 i8)))

  (let %reader (index %this 0))

  (let %done (call @Reader$ptr.done (args %reader)))
  (if %done (do
    (call @Reader$ptr.reset (args %reader))
    (return-void)
  ))

  (let %c (call @Reader$ptr.get (args %reader)))

  (if (== %COMMENT_STATE %state) (do
    (if (== %NEWLINE %c) (do
      (call-tail @Parser$ptr.remove-comments (args %this %START_STATE))
      (return-void)
    ))
; TODO assert %prev != (0 i8)
    (store %SPACE (cast i8* (- (cast u64 (load (index %reader 1))) 1)))
    (call-tail @Parser$ptr.remove-comments (args %this %state))
    (return-void)
  ))

  (if (== %START_STATE %state) (do
    (if (== %QUOTE %c) (do
      (call-tail @Parser$ptr.remove-comments (args %this %STRING_STATE))
      (return-void)
    ))

; TODO APOSTROPHE comparison for CHAR_STATE
    
    (if (== %SEMICOLON %c) (do
; TODO assert %prev != (0 i8)
      (store %SPACE (cast i8* (- (cast u64 (load (index %reader 1))) 1)))
      (call-tail @Parser$ptr.remove-comments (args %this %COMMENT_STATE))
      (return-void)
    ))

    (call-tail @Parser$ptr.remove-comments (args %this %state))
    (return-void)
  ))

  (if (== %STRING_STATE %state) (do
; consider using @Parser$ptr.string_ for this    
    (if (== %QUOTE %c) (do
      (let %prev (load (index %reader 2)))
      (if (!= %BACKSLASH %prev) (do
        (call-tail @Parser$ptr.remove-comments (args %this %START_STATE))
        (return-void)
      ))
    ))

    (call-tail @Parser$ptr.remove-comments (args %this %state))
    (return-void)
  ))

; TODO handle CHAR_STATE

  (return-void)
))

(def @Parser.parse-file (params (%filename %struct.StringView*)) %struct.Texp (do
  (auto %file %struct.File)
  (store (call @File.openrw (args %filename)) %file)

  (auto %content %struct.StringView)
  (store (call @File$ptr.readwrite (args %file)) %content)

  (auto %parser %struct.Parser)
  (call @Reader$ptr.set (args (index %parser 0) %content))

  (call @Parser$ptr.remove-comments (args %parser 0))

  (auto %prog %struct.Texp) 
  (auto %filename-string %struct.String)
  (store (call @String.makeFromStringView (args %filename)) %filename-string)
  (call @Texp$ptr.setFromString (args %prog %filename-string))

  (call @Parser$ptr.collect (args %parser %prog))

  (call @File.unread (args %content))
  (call @File$ptr.close (args %file))
  (return (load %prog))
))

;========== Parser tests ==========================================================================

(def @test.parser-whitespace params void (do
  (auto %filename %struct.StringView)
  (call @StringView$ptr.set (args %filename ""))
  
  (auto %file %struct.File)
  (store (call @File.open (args %filename)) %file)
  
  (auto %content %struct.StringView)
  (store (call @File$ptr.read (args %file)) %content)

  (auto %parser %struct.Parser)
  (call @Reader$ptr.set (args (index %parser 0) %content))

  (call @puts (args (load (index (index %parser 0) 1))))

  (call @Parser$ptr.whitespace (args %parser))
  (call @puts (args (load (index (index %parser 0) 1))))

  (call @Parser$ptr.whitespace (args %parser))
  (call @puts (args (load (index (index %parser 0) 1))))

  (call @Reader$ptr.get (args (index %parser 0)))
  (call @puts (args (load (index (index %parser 0) 1))))

  (call @Parser$ptr.whitespace (args %parser))
  (call @puts (args (load (index (index %parser 0) 1))))

  (call @File.unread (args %content))
  (call @File$ptr.close (args %file))
  (return-void)
))

(def @test.parser-atom params void (do
  (auto %filename %struct.StringView)
  (call @StringView$ptr.set (args %filename "huh\00"))
  
  (auto %file %struct.File)
  (store (call @File.open (args %filename)) %file)
  
  (auto %content %struct.StringView)
  (store (call @File$ptr.read (args %file)) %content)

  (auto %parser %struct.Parser)
  (call @Reader$ptr.set (args (index %parser 0) %content))

  (call @puts (args (load (index (index %parser 0) 1))))

  (auto %texp %struct.Texp)
  (store (call @Parser$ptr.atom (args %parser)) %texp)
  (call @puts (args (load (index (index %parser 0) 1))))

  (call @Texp$ptr.parenPrint (args %texp))
  (call @println args)

  (auto %texp2 %struct.Texp)
  (store (call @Parser$ptr.atom (args %parser)) %texp2)
  (call @puts (args (load (index (index %parser 0) 1))))

  (call @Texp$ptr.parenPrint (args %texp2))
  (call @println args)

  (call @File.unread (args %content))
  (call @File$ptr.close (args %file))
  (return-void)
))

(def @test.parser-texp params void (do
  (auto %filename %struct.StringView)
  (call @StringView$ptr.set (args %filename "lib2/core.bb.type.tall\00"))
  
  (auto %file %struct.File)
  (store (call @File.open (args %filename)) %file)
  
  (auto %content %struct.StringView)
  (store (call @File$ptr.read (args %file)) %content)

  (auto %parser %struct.Parser)
  (call @Reader$ptr.set (args (index %parser 0) %content))

  (call @puts (args (load (index (index %parser 0) 1))))

  (auto %texp %struct.Texp)
  (store (call @Parser$ptr.texp (args %parser)) %texp)
  (call @puts (args (load (index (index %parser 0) 1))))

  (call @Texp$ptr.parenPrint (args %texp))
  (call @println args)

  (call @File.unread (args %content))
  (call @File$ptr.close (args %file))
  (return-void)
))

(def @test.parser-string params void (do
  (auto %filename %struct.StringView)
  (call @StringView$ptr.set (args %filename "../backbone-test/texp-parser/string.texp\00"))
  
  (auto %file %struct.File)
  (store (call @File.open (args %filename)) %file)
  
  (auto %content %struct.StringView)
  (store (call @File$ptr.read (args %file)) %content)

  (auto %parser %struct.Parser)
  (call @Reader$ptr.set (args (index %parser 0) %content))

  (call @puts (args (load (index (index %parser 0) 1))))

  (auto %texp %struct.Texp)
  (store (call @Parser$ptr.texp (args %parser)) %texp)
  (call @puts (args (load (index (index %parser 0) 1))))

  (call @Texp$ptr.parenPrint (args %texp))
  (call @println args)
  (call @u64.print (args (load (index %texp 2))))
  (call @println args)

  (call @File.unread (args %content))
  (call @File$ptr.close (args %file))
  (return-void)
))

(def @test.parser-comments params void (do
  (auto %filename %struct.StringView)
	(call @StringView$ptr.set (args %filename "lib2/core.bb.type.tall\00"))
  
  (auto %file %struct.File)
  (store (call @File.openrw (args %filename)) %file)

  (auto %content %struct.StringView)
  (store (call @File$ptr.readwrite (args %file)) %content)

  (auto %parser %struct.Parser)
  (call @Reader$ptr.set (args (index %parser 0) %content))

  (call @Parser$ptr.remove-comments (args %parser 0))

  (call @puts (args (load (index (index %parser 0) 1))))

  (auto %texp %struct.Texp)
  (store (call @Parser$ptr.texp (args %parser)) %texp)
  
  (call @Texp$ptr.parenPrint (args %texp))
  (call @println args)

  (call @File.unread (args %content))
  (call @File$ptr.close (args %file))

  (return-void)
))

(def @test.parser-file params void (do
  (auto %filename %struct.StringView)
	(call @StringView$ptr.set (args %filename "lib2/core.bb.type.tall\00"))
  
  (auto %file %struct.File)
  (store (call @File.openrw (args %filename)) %file)

  (auto %content %struct.StringView)
  (store (call @File$ptr.readwrite (args %file)) %content)

  (auto %parser %struct.Parser)
  (call @Reader$ptr.set (args (index %parser 0) %content))

  (call @Parser$ptr.remove-comments (args %parser 0))

  (auto %prog %struct.Texp) 
  (auto %filename-string %struct.String)
  (store (call @String.makeFromStringView (args %filename)) %filename-string)
  (call @Texp$ptr.setFromString (args %prog %filename-string))

  (call @Parser$ptr.collect (args %parser %prog))

  (call @Texp$ptr.parenPrint (args %prog))

  (call @File.unread (args %content))
  (call @File$ptr.close (args %file))
  (return-void)
))

;========== Pretty Printer ========================================================================

(def @Texp$ptr.pretty-print$lambda.do (params (%this %struct.Texp*)) void (do
; TODO consider adding stmt level pretty printing with indentation
  (return-void)
))

(def @Texp$ptr.pretty-print$lambda.toplevel (params (%this %struct.Texp*) (%last %struct.Texp*)) void (do
  (call @Texp$ptr.parenPrint (args %this))
  (call @println args)
  (if (!= %this %last) (do 
    (let %next (cast %struct.Texp* (+ 40 (cast u64 %this))))
    (call @Texp$ptr.pretty-print$lambda.toplevel (args %next %last))
  ))
  (return-void)
))

(def @Texp$ptr.pretty-print (params (%this %struct.Texp*)) void (do
  (let %last (call @Texp$ptr.last (args %this)))
  (let %first-child (load (index %this 1)))
  (call @Texp$ptr.pretty-print$lambda.toplevel (args %first-child %last))
  (return-void)
))

;========== Pretty Printer tests ===================================================================

(def @test.texp-pretty-print params void (do
  (auto %filename %struct.StringView)
	(call @StringView$ptr.set (args %filename "lib2/core.bb.type.tall\00"))
  
  (auto %prog %struct.Texp)
  (store (call @Parser.parse-file (args %filename)) %prog)

  (call @Texp$ptr.pretty-print (args %prog))
  (return-void)
))

;========== Grammar ===============================================================================

(struct %struct.Grammar
  (%texp %struct.Texp))

(def @Grammar.make (params (%texp %struct.Texp)) %struct.Grammar (do
  (auto %grammar %struct.Grammar)
  (store %texp (index %grammar 0))
  (return (load %grammar))
))

(def @Grammar$ptr.getProduction (params (%this %struct.Grammar*) (%type-name %struct.StringView*)) %struct.Texp* (do
  (let %maybe-prod (call @Texp$ptr.find (args (index %this 0) %type-name)))
  (if (== 0 (cast u64 %maybe-prod)) (do
    (auto %msg %struct.StringView)
    (store (call @StringView.makeFromi8$ptr (args "production not found\00")) %msg)
    (call @StringView$ptr.print (args %msg))
    (call @exit (args 1))
  ))

  (return %maybe-prod)
))

;========== Matcher ===============================================================================

(struct %struct.Matcher
  (%grammar %struct.Grammar))

(def @Matcher$ptr.is (params (%this %struct.Matcher*) (%texp %struct.Texp*) (%type-name %struct.StringView*)) %struct.Texp (do
  (let %grammar (index %this 0))
  (let %rule (call @Grammar$ptr.getProduction (args %grammar %type-name)))
  (auto %result %struct.Texp)
  (store (call @Matcher$ptr.match (args %this %texp %rule)) %result)
  (let %result-value (call @Texp$ptr.value-view (args %result)))
  (if (call @StringView.eq (args %result-value (call @StringView.makeFromi8$ptr (args "success\00")))) (do
    (let %proof-value (index (index (index %this 0) 0) 0))
    (auto %new-proof-value %struct.String)
    (store (call @String.makeFromStringView (args %type-name)) %new-proof-value)
    (let %FORWARD_SLASH (+ 47 (0 i8)))
    (call @String$ptr.pushChar (args %new-proof-value %FORWARD_SLASH))
    (call @String$ptr.append (args %new-proof-value %proof-value))
    (call @String$ptr.free (args %proof-value))
    (store (load %new-proof-value) %proof-value)
  ))
  (return (load %result))
))

(def @Matcher$ptr.match (params (%this %struct.Matcher*) (%texp %struct.Texp*) (%rule %struct.Texp*)) %struct.Texp (do
  (if (call @Texp$ptr.value-check (args %texp "|\00")) (do
    (return (call @Matcher$ptr.choice (args %this %texp %rule)))
  ))

  (let %value-result (call @Matcher$ptr.value (args %this %texp %rule)))
; check for error
  (if (call @Texp$ptr.value-check (args %texp "error\00")) (do
    (return %value-result)
  ))

  (let %length (load (index %rule 2)))
  (let %last (call @Texp$ptr.last (args %rule)))
  (if (* (!= %length 0) (call @Texp$ptr.value-check (args %rule "*\00"))) (do
    (return (call @Matcher$ptr.kleene (args %this %texp %rule)))
  ))

  (return (call @Matcher$ptr.exact (args %this %texp %rule)))
))

(def @Matcher$ptr.kleene-many (params (%this %struct.Matcher*) (%texp %struct.Texp*) (%rule %struct.Texp*) (%start u64)) void (do
; CURRENT
  (return-void)
))

(def @Matcher$ptr.kleene-seq (params 
      (%this %struct.Matcher*) (%texp %struct.Texp*) (%rule %struct.Texp*) (%acc %struct.Texp*)
      (%curr-index u64) (%last-index u64))
    void (do
; TODO let %last-rule ()
; TODO assert (== (- %rule) (- %last-texp %texp))
  (let %texp-child (call @Texp$ptr.child (args %texp %curr-index)))
  (let %rule-child (call @Texp$ptr.child (args %rule %curr-index)))

  (let %result (call @Matcher$ptr.is (args %this %texp-child (call @Texp$ptr.value-view (args %rule-child)))))

; if the check is not successful, clear the accumulator and set the error code.
; CONSIDER loading the accumulator and rearranging the Texp to keep the current continuation of proof
  (if (call @Texp$ptr.value-check (args %result "error\00")) (do
    (call @Texp$ptr.free (args %acc))
    (store %result %acc)
    (return-void)
  ))

  (call @Texp$ptr.push (args %acc %result))
  (if (== %curr-index %last-index) (do (return-void)))
  (let %next-index (+ 1 %curr-index))
  (call @Matcher$ptr.kleene-seq (args %this %texp %rule %acc %next-index %last-index))
  (return-void)
))

(def @Matcher$ptr.kleene (params (%this %struct.Matcher*) (%texp %struct.Texp*) (%rule %struct.Texp*)) %struct.Texp (do
  (let %last (call @Texp$ptr.last (args %rule)))
  (let %last-length (load (index %last 2)))
  (if (!= 1 %last-length) (do
    (call @puts (args "error\00"))
    (call @exit (args 1))
  ))
  (let %kleene-prod-view (call @String$ptr.view (args (index %last 0))))

  (if (< (load (index %texp 2)) (- (load (index %rule 2)) 1)) (do
    (auto %failure-result %struct.Texp)
    (store (call @Texp.makeFromi8$ptr (args "failure\00")) %failure-result)

; CURRENT
    (call @Texp$ptr.push (args %failure-result 
      (call @Texp.makeFromi8$ptr (args "texp length not less than for rule.len - 1\00"))))
    (call @Texp$ptr.push (args %failure-result (call @Texp$ptr.clone (args %rule))))
    (call @Texp$ptr.push (args %failure-result (call @Texp$ptr.clone (args %texp))))
    (return (load %failure-result))
  ))

  (auto %proof %struct.Texp)
  (store (call @Texp.makeFromi8$ptr (args "kleene\00")) %proof)
  (let %seq (call @Matcher$ptr.kleene-seq (args %this %texp %rule %proof 0 (- (load (index %rule 2)) 1))))
))

(def @Matcher$ptr.exact (params (%this %struct.Matcher*) (%texp %struct.Texp*) (%rule %struct.Texp*)) %struct.Texp (do
; LATER
))

(def @Matcher$ptr.choice (params (%this %struct.Matcher*) (%texp %struct.Texp*) (%rule %struct.Texp*)) %struct.Texp (do
; LATER
))

(def @Matcher$ptr.value (params (%this %struct.Matcher*) (%texp %struct.Texp*) (%rule %struct.Texp*)) %struct.Texp (do
; LATER
))

;========== main program ==========================================================================

(def @main params i32 (do
  (call @test.Texp-clone args)
  (return 0)
))
